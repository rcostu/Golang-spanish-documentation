<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" >
<title>Un tour por Go</title>

<!-- jQuery -->
<script src="static/jquery.js"></script>

<!-- Fonts -->
<link href='http://fonts.googleapis.com/css?family=Droid+Serif&v1' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=Droid+Sans&v1' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=Droid+Sans+Mono&v1' rel='stylesheet' type='text/css'>

<!-- Playground -->
<link rel="stylesheet" href="/static/codemirror/lib/codemirror.css">
<script src="/static/codemirror/lib/codemirror.js"></script>
<link rel="stylesheet" href="/static/codemirror/theme/default.css">
<script src="static/playground.js"></script>

<!-- Tour -->
<link rel="stylesheet" href="static/tour.css" charset="utf-8">
<script src="static/mode.js"></script>
<script src="static/tour.js"></script>

</head>
<body class="loading">

<!-- Top bar -->
<h2 id="slidenum"></h2>
<div id="topnav" class="nav">
	<button id="tocbtn">ÍNDICE</button>
</div>
<h1>Un tour por Go</h1>

<!-- Loading message -->
<div id="loading">
	Cargando diapositivas...
</div>

<!-- Table of Contents -->
<ol id="toc"></ol>

<div id="slides" class="slides"><!-- begin slides -->

<div class="toc">Bienvenidos</div>

<div class="slide">
	<h2>Hola, 世界</h2>
	<p>
	Bienvenido al tour por el
	<a target="_blank" href="http://golang.org/">lenguaje de programación Go</a>.
	<p>
	El tour está dividido en tres secciones. Al final de cada sección
	hay una serie de ejercicios para que los completes.
	<p>
	El tour es interacticvo. Haz click en Ejecutar (o presiona
	Shift-Enter) para compilar y ejecutar el programa en
	<span class="appengineMode">un servidor remoto.</span>
	<span class="localMode">tu ordenador.</span>
	El resultado se mostrará debajo del código.
	<p>
	Estos programas de ejemplo muestran los diferentes aspectos de Go. Se
	supone que los programas del tour han de ser los puntos de partida de tus
	propios experimentos.
	<p>
	Modifica el programa y ejecútalo de nuevo.
	<p>
	Cuando estés listo para continuar, haz click en Siguiente
	o presiona la tecla PageDown.
<div>
package main

import "fmt"

func main() {
	fmt.Println("Hola, 世界")
}
</div>
</div>

<div class="slide nocode appengineMode">
	<h2>Go offline</h2>
	<p>
	Este tour está disponible también como un programa independiente que puedes
	usar sin acceder a internet.
	<p>
	Este programa es rápido, ya que compila y ejecuta el código de los ejemplos
	en tu propio ordenador. También incluye ejercicos adicionales que no se
	encuentran disponibles en la versión online.
	<p>
	Para ejecutar el tour localmente primero debes
	<a target="_blank" href="http://golang.org/doc/install.html">instalar Go</a>
	(la ultima versión estable, <code>release.r60.3</code>),
	a continuación
	<a target="_blank" href="http://golang.org/cmd/goinstall/">goinstall</a>
	para instalar
	<a target="_blank" href="http://code.google.com/p/go-tour/">gotour</a>:
	<pre>    goinstall go-tour.googlecode.com/hg/gotour</pre>
	<p>
	y ejecuta el fichero <code>gotour</code>.
	<p>
	De lo contrario, haz click en "siguiente" o presiona la tecla
	PageDown para continuar.
	<p>
	<i>
		(Puedes volver a estas instrucciones en cualquier momento haciendo click
		en "índice".)</i>
</div>

<div class="toc">Introducción</div>

<div class="slide">
	<h2>Paquetes</h2>
	<p>
	Todo programa en Go contiene paquetes.
	<p>
	Los programas comienzan su ejecución en el paquete <code>main</code>.
	<p>
	Este programa usa los paquetes con rutas de importación
	<code>"fmt"</code> y <code>"math"</code>.
	<p>
	Por convención, el nombre del paquete es el mismo que el último elemento de
	la ruta de importación.
<div>
package main

import (
	"fmt"
	"math"
)

func main() {
	fmt.Println("Feliz día", math.Pi)
}
</div>
</div>

<div class="slide">
	<h2>Importación</h2>
	<p>
	Éste código agrupa las importaciones entre paréntesis de forma
	"factorizada". Tambien puedes realizar multiples importaciones de la
	siguiente forma:
	<pre>
	import "fmt"
	import "math"
	</pre>
	pero es común usar la forma factorizada para eliminar código innecesario.
<div>
package main

import (
	"fmt"
	"math"
)

func main() {
	fmt.Printf("Ahora tienes %g problemas.",
		math.Nextafter(2, 3))
}
</div>
</div>

<div class="slide">
	<h2>Identificadores exportados</h2>
	<p>
	Tras importar un paquete, puedes hacer referencia a los identificadores que
	exporta.
	<p>
	En Go, un identificador es exportado si empieza por una mayúscula.
	<p>
	<code>Pi</code> es un identificador exportado, al igual que <code>PI</code>.
	El identificador <code>pi</code> no es exportado.
	<p>
	Ejecuta el código. Después sustituye <code>math.pi</code> por <code>math.Pi</code>
	e intentalo de nuevo.
<div>
package main

import (
	"fmt"
	"math"
)

func main() {
	fmt.Println(math.pi)
}
</div>
</div>

<div class="slide">
	<h2>Funciones</h2>
	<p>
	Una función puede tener cero o más argumentos.
	<p>
	En este ejemplo, <code>add</code> posee dos parámetros de tipo <code>int</code>.
	<p>
	Observa que el tipo de indica <i>después</i> del nombre de la variable.
	<p>
	Para más información acerca de por qué los tipos se miestran así, échale un
	vistazo a <a target="_blank"
		href="http://blog.golang.org/2010/07/gos-declaration-syntax.html">ésta
		entrada</a> en inglés.)
<div>
package main

import "fmt"

func add(x int, y int) int {
	return x + y
}

func main() {
	fmt.Println(add(42, 13))
}
</div>
</div>

<div class="slide">
	<h2>Funciones</h2>
	<p>
	Cuando dos o más parámetros consecutivos de la función son del mismo tipo,
	puedes omitir el tipo de todos menos del último.
	<p>
	En el ejemplo, acortamos
	<pre>x int, y int</pre>
	<p>
	a
	<pre>x, y int</pre>
<div>
package main

import "fmt"

func add(x, y int) int {
	return x + y
}

func main() {
	fmt.Println(add(42, 13))
}
</div>
</div>

<div class="slide">
	<h2>Funciones</h2>
	<p>
	Una función puede devolver varios resultados.
	<p>
	Esta función devuelve dos cadenas.
<div>
package main

import "fmt"

func swap(x, y string) (string, string) {
	return y, x
}

func main() {
	a, b := swap("hola", "mundo")
	fmt.Println(a, b)
}
</div>
</div>

<div class="slide">
	<h2>Funciones</h2>
	<p>
	Las funciones tienen parametros; en Go los resultados pueden ser nombrados
	y actuar como variables; se les denomina "variables de retorno"
	<p>
	Si las variables de retorno tienen un nombre, una sentencia <code>return</code>
	sin argumentos devuelve el valor actual de dichas variables.
<div>
package main

import "fmt"

func split(sum int) (x, y int) {
	x = sum * 4/9
	y = sum - x
	return
}

func main() {
	fmt.Println(split(17))
}
</div>
</div>

<div class="slide">
	<h2>Variables</h2>
	<p>
	La sentencia <code>var</code> declara una lista de variables;
	como en la lista de argumentos de las funciones, el tipo se indica al final.
<div>
package main

import "fmt"

var x, y, z int
var c, python, java bool

func main() {
	fmt.Println(x, y, z, c, python, java)
}
</div>
</div>

<div class="slide">
	<h2>Variables</h2>
	<p>
	La declaracion de variables permite inicializaciones, una por variable.
	<p>
	Si se inicializa una variable, el tipo puede omitirse;
	la variable adoptará el tipo del valor con el que ha sido inicializada.
<div>
package main

import "fmt"

var x, y, z int = 1, 2, 3
var c, python, java = true, false, "no!"

func main() {
	fmt.Println(x, y, z, c, python, java)
}
</div>
</div>

<div class="slide">
	<h2>Variables</h2>
	<p>
	Dentro de una función, puede utilizarse la sentencia de asignación <code>:=</code> <!--short
	assignment statement-->
	en lugar de la declaración <code>var</code>.
	<p>
	(Fuera de una función, todas las declaraciones de variables comienzan con la
	palabra clave <code>var</code> y el operando <code>:=</code> no está disponible.)
<div>
package main

import "fmt"

func main() {
	var x, y, z int = 1, 2, 3
	c, python, java := true, false, "no!"

	fmt.Println(x, y, z, c, python, java)
}
</div>
</div>

<div class="slide">
	<h2>Constantes</h2>
	<p>
	Las constantes se declaran como las variables, pero con la palabra reservada
	<code>const</code>.
	<p>
	Las constantes pueden ser cadenas, booleanas, o numéricas.
<div>
package main

import "fmt"

const Pi = 3.14

func main() {
	const Mundo = "世界"
	fmt.Println("Hola", Mundo)
	fmt.Println("Feliz día de ", Pi)

	const Truth = true
	fmt.Println("¿Go mola?", Truth)
}
</div>
</div>

<div class="slide">
	<h2>Constantes Numéricas</h2>
	<p>
	Las constantes numéricas son <i>valores</i> de alta precisión.
	<p>
	Una constante sin un tipo definido tiene el tipo necesitado según el
	contexto en el que se declara.
	<p>
	Intenta también imprimir el valor <code>needInt(Big)</code>.
<div>
package main

import "fmt"

const (
	Big = 1<<100
	Small = Big>>99
)

func needInt(x int) int { return x*10 + 1 }
func needFloat(x float64) float64 {
	return x*0.1
}

func main() {
	fmt.Println(needInt(Small))
	fmt.Println(needFloat(Small))
	fmt.Println(needFloat(Big))
}
</div>
</div>

<div class="slide">
	<h2>For</h2>
	<p>
	Go tiene sólo un operando para definir los bucles, los bucles
	<code>for</code>.
	<p>
	El bucle <code>for</code> básico es muy parecido al que se utiliza en
	C o Java, salvo que los <code>( )</code> desaparecen (ni siquiera son
	opcionales) y las llaves <code>{ }</code> son obligatorias.
<div>
package main

import "fmt"

func main() {
	sum := 0
	for i := 0; i < 10; i++ {
		sum += i
	}
	fmt.Println(sum)
}
</div>
</div>

<div class="slide">
	<h2>For</h2>
	<p>
	Como en C o Java, puedes dejar las instrucciones de inicialización
	e incremento vacías.
<div>
package main

import "fmt"

func main() {
	sum := 1
	for ; sum < 1000; {
		sum += sum
	}
	fmt.Println(sum)
}
</div>
</div>

<div class="slide">
	<h2>For</h2>
	<p>
	En este paso, puedes eliminar los puntos y coma <code>;</code>:
	Un bucle <code>while</code> de C se transforma en un bucle <code>for</code>
	en Go.
<div>
package main

import "fmt"

func main() {
	sum := 1
	for sum < 1000 {
		sum += sum
	}
	fmt.Println(sum)
}
</div>
</div>

<div class="slide">
	<h2>For</h2>
	<p>
	Si omites la condición del bucle, es un bucle infinito.
<div>
package main

func main() {
	for ; ; {
	}
}
</div>
</div>

<div class="slide">
	<h2>For</h2>
	<p>
	Y sin ninguna cláusula, los puntos y coma <code>;</code> pueden omitirse, de
	forma que un bucle infinito se expresa de forma compacta.
<div>
package main

func main() {
	for {
	}
}
</div>
</div>

<div class="slide">
	<h2>If</h2>
	<p>
	La instrucción <code>if</code> es similar a la sentencia en C o Java, salvo
	que los paréntesis <code>( )</code> desaparecen (ni siquiera son opcionales)
	y las llaves <code>{ }</code> son obligatorias.
	<p>
	(¿Te suena de algo?)
<div>
package main

import (
	"fmt"
	"math"
)

func sqrt(x float64) string {
	if x < 0 {
		return sqrt(-x) + "i"
	}
	return fmt.Sprint(math.Sqrt(x))
}

func main() {
	fmt.Println(sqrt(2), sqrt(-4))
}
</div>
</div>

<div class="slide">
	<h2>If</h2>
	<p>
	Al igual que en la sentencia <code>for</code>, la sentencia <code>if</code>
	puede empezar con una instrucción de inicialización que se ejecutará antes
	de evaluar la condición.
	<p>
	Las variables declaradas por la instrucción de inicialización son únicamente
	visibles en el ámbito del <code>if</code>.
	<p>
	(Intenta usar <code>v</code> en la última sentencia <code>return</code>.)
<div>
package main

import (
	"fmt"
	"math"
)

func pow(x, n, lim float64) float64 {
	if v := math.Pow(x, n); v < lim {
		return v
	}
	return lim
}

func main() {
	fmt.Println(
		pow(3, 2, 10),
		pow(3, 3, 20),
	)
}
</div>
</div>

<div class="slide">
	<h2>If</h2>
	<p>
	Las variables declaradas dentro de la instrucción de inicialización de un
	<code>if</code> son también visibles dentro de los bloques <code>else</code>.
<div>
package main

import (
	"fmt"
	"math"
)

func pow(x, n, lim float64) float64 {
	if v := math.Pow(x, n); v < lim {
		return v
	} else {
		fmt.Printf("%g >= %g\n", v, lim)
	}
	// No se puede usar v aquí
	return lim
}

func main() {
	fmt.Println(
		pow(3, 2, 10),
		pow(3, 3, 20),
	)
}
</div>
</div>

<div class="slide">
	<h2>Tipos básicos</h2>
	<p>
	Los tipos básicos en Go son:
	<pre>
bool

string

int  int8  int16  int32  int64
uint uint8 uint16 uint32 uint64 uintptr

float32 float64

complex64 complex128
	</pre>
<div>
package main

import (
	"cmath"
	"fmt"
)

var (
	ToBe bool = false
	MaxInt uint64 = 1<<64 - 1
	z complex128 = cmath.Sqrt(-5+12i)
)

func main() {
	const f = "%T(%v)\n"
	fmt.Printf(f, ToBe, ToBe)
	fmt.Printf(f, MaxInt, MaxInt)
	fmt.Printf(f, z, z)
}
</div>
</div>

<div class="slide">
	<h2>Estructuras</h2>
	<p>
	Una estructura (<code>struct</code>) es un registro de variables dentro de un mismo tipo.
	<p>
	(Y una declaración <code>type</code> declara un nuevo tipo de datos.)
<div>
package main

import "fmt"

type Vertex struct {
	X int
	Y int
}

func main() {
	fmt.Println(Vertex{1, 2})
}
</div>
</div>

<div class="slide">
	<h2>Campos de una estructura</h2>
	<p>
	Los campos de una estructura son accesibles mediante el operador
	<code>.</code> (punto).
<div>
package main

import "fmt"

type Vertex struct {
	X int
	Y int
}

func main() {
	v := Vertex{1, 2}
	v.X = 4
	fmt.Println(v.X)
}
</div>
</div>

<div class="slide">
	<h2>Punteros</h2>
	<p>
	Go posee punteros, pero no tiene aritmética de punteros (como C).
	<p>
	Los campos de las estructuras pueden accederse a través de un puntero a una
	estructura.
	La indirección del puntero es transparente al programador.
<div>
package main

import "fmt"

type Vertex struct {
	X int
	Y int
}

func main() {
	p := Vertex{1, 2}
	q := &p
	q.X = 1e9
	fmt.Println(p)
}
</div>
</div>

<div class="slide">
	<h2>Estructuras literales</h2>
	<p>
	Una estructura literal denota una nueva instancia de la estructura que
	muestra los valores de sus campos.
	<p>
	Puedes mostrar sólo un subconjunto de los campos utilizando la sintaxis
	<code>Name:</code>. (Y el orden de los campos nombrados es irrelevante.)
	<p>
	El prefijo especial <code>&</code> construye un puntero a una estructura
	literal.
<div>
package main

import "fmt"

type Vertex struct {
	X, Y int
}

var (
	p = Vertex{1, 2}  // Tiene tipo Vertex
	q = &Vertex{1, 2} // Tiene tipo *Vertex
	r = Vertex{X: 1}  // Y:0 es implícito
	s = Vertex{}      // X:0 e Y:0
)

func main() {
	fmt.Println(p, q, r, s)
}
</div>
</div>

<div class="slide">
	<h2>La función <code>new</code></h2>
	<p>
	La expresión <code>new(T)</code> aloja en memoria un valor <code>T</code>
	inicializado a 0 y retorna un puntero al mismo.
	<pre>var t *T = new(T)</pre>
	<p>
	o
	<pre>t := new(T)</pre>
<div>
package main

import "fmt"

type Vertex struct {
	X, Y int
}

func main() {
	v := new(Vertex)
	fmt.Println(v)
	v.X, v.Y = 11, 9
	fmt.Println(v)
}
</div>
</div>

<div class="slide">
	<h2>Maps</h2>
	<p>
	Un map relaciona claves y valores.
	<p>
	<!-- TODO: empty part not true in compilers yet -->
	Los Maps deben crearse con la función <code>make</code> (nunca con
	<code>new</code>) antes de su uso; el map <code>nil</code> está vacío y no
	puede ser asignado.
<div>
package main

import "fmt"

type Vertex struct {
	Lat, Long float64
}

var m map[string]Vertex

func main() {
	m = make(map[string]Vertex)
	m["Bell Labs"] = Vertex{
		40.68433, 74.39967,
	}
	fmt.Println(m["Bell Labs"])
}
</div>
</div>

<div class="slide">
	<h2>Maps</h2>
	<p>
	Los map literales son como las estructuras literales, pero las claves son
	obligatorias.
<div>
package main

import "fmt"

type Vertex struct {
	Lat, Long float64
}

var m = map[string]Vertex{
	"Bell Labs": Vertex{
		40.68433, -74.39967,
	},
	"Google": Vertex{
		37.42202, -122.08408,
	},
}

func main() {
	fmt.Println(m)
}
</div>
</div>

<div class="slide">
	<h2>Maps</h2>
	<p>
	Si el tipo superior es un nombre de un tipo, puedes omitirlo de los
	elementos del literal.
<div>
package main

import "fmt"

type Vertex struct {
	Lat, Long float64
}

var m = map[string]Vertex{
	"Bell Labs": {40.68433, -74.39967},
	"Google":    {37.42202, -122.08408},
}

func main() {
	fmt.Println(m)
}
</div>
</div>

<div class="slide">
	<h2>Slices</h2>
	<p>
	Un slice apunta a un array de valores y posee un tamaño.
	<p>
	<code>[]T</code> es un slice con elementos de tipo <code>T</code>.
<div>
package main

import "fmt"

func main() {
	p := []int{2, 3, 5, 7, 11, 13}
	fmt.Println("p ==", p)

	for i := 0; i < len(p); i++ {
		fmt.Printf("p[%d] == %d\n",
			i, p[i])
	}
}
</div>
</div>

<div class="slide">
	<h2>Slices</h2>
	<p>
	Los slices pueden ser reasignados, creando un nuevo slice que apunte al
	mismo array.
	<p>
	La expresión
	<pre>s[lo:hi]</pre>
	<p>
	es evaluada como un slice de elementos desde el elemento de índice
	<code>lo</code> hasta el elemento <code>hi-1</code> inclusive. Por tanto
	<pre>s[lo:lo]</pre>
	<p>
	es un slice vacío y
	<pre>s[lo:lo+1]</pre>
	<p>
	tiene un elemento.
<div>
package main

import "fmt"

func main() {
	p := []int{2, 3, 5, 7, 11, 13}
	fmt.Println("p ==", p)
	fmt.Println("p[1:4] ==", p[1:4])

	// Un valor de inicio omitido implica 0
	fmt.Println("p[:3] ==", p[:3])

	// Un valor de fin omitido implica len(s)
	fmt.Println("p[4:] ==", p[4:])
}
</div>
</div>

<div class="slide">
	<h2>Slices</h2>
	<p>
	Los slices son creados con la función <code>make</code>. Funciona alojando
	un array inicializado a 0 y retornando un slice que apunta a ese array:
	<pre>
a := make([]int, 5)  // len(a)=5
	</pre>
	Los slices tienen un tamaño y una capacidad. La capacidad de un slice es el
	tamaño máximo que el slice puede crecer dentro del array al que apunta.
	<p>
	Para especificar una capacidad basta con pasar un tercer argumento a <code>make</code>:
	<p>
	<pre>
b := make([]int, 0, 5)
// len(b)=0, cap(b)=5
	</pre>
	Los slices pueden crecer reasignándose (por encima de su capacidad):
	<p>
	<pre>
b = b[:cap(b)] // len(b)=5, cap(b)=5
b = b[1:]      // len(b)=4, cap(b)=4
	</pre>
<div>
package main

import "fmt"

func main() {
	a := make([]int, 5)
	printSlice("a", a)
	b := make([]int, 0, 5)
	printSlice("b", b)
	c := b[:2]
	printSlice("c", c)
	d := c[2:5]
	printSlice("d", d)
}

func printSlice(s string, x []int) {
	fmt.Printf("%s len=%d cap=%d %v\n",
		s, len(x), cap(x), x)
}
</div>
</div>

<div class="slide">
	<h2>Slices</h2>
	<p>
	El valor por defecto de un slice es <code>nil</code>.
	<p>
	Un slice <code>nil</code> tiene un tamaño y una longitud de 0.
	<p>
	<i>Para más detalle por favor mira el artículo (en inglés) 
	"<a target="_blank" href="http://blog.golang.org/2011/01/go-slices-usage-and-internals.html">Go Slices: usage and internals</a>"
	</i>
<div>
package main

import "fmt"

func main() {
	var z []int
	fmt.Println(z, len(z), cap(z))
	if z == nil {
		fmt.Println("¡nulo!")
	}
}
</div>
</div>

<div class="slide">
	<h2>Funciones</h2>
	<p>
	Las funciones también son valores.
<div>
package main

import (
	"fmt"
	"math"
)

func main() {
	hypot := func(x, y float64) float64 {
		return math.Sqrt(x*x + y*y)
	}

	fmt.Println(hypot(3, 4))
}
</div>
</div>

<div class="slide">
	<h2>Funciones</h2>
	<p>
	Y las funciones son clausuras completas.
	<p>
	La función <code>adder</code> retorna una clausura (o función anónima).
	Cada clausura está vinculada a su variable <code>sum</code> correspondiente.
<div>
package main

import "fmt"

func adder() func(int) int {
	sum := 0
	return func(x int) int {
		sum += x
		return sum
	}
}

func main() {
	pos, neg := adder(), adder()
	for i := 0; i < 10; i++ {
		fmt.Println(
			pos(i),
			neg(-2*i),
		)
	}
}
</div>
</div>

<div class="slide">
	<h2>Range</h2>
	<p>
	La forma <code>range</code> de un bucle <code>for</code> itera sobre
	elementos de un slice o un map.
<div>
package main

import "fmt"

var pow = []int{1, 2, 4, 8, 16, 32, 64, 128}

func main() {
	for i, v := range pow {
	    fmt.Printf("2**%d = %d\n", i, v)
	}
}
</div>
</div>

<div class="slide">
	<h2>Range</h2>
	<p>
	Puedes obviar la clave o el valor asignándoselo a <code>_</code>.
	<p>
	Si sólo quieres el índice, descarta el 
	&ldquo;<code>, value</code>&rdquo; integramente.
<div>
package main

import "fmt"

func main() {
	pow := make([]int, 10)
	for i := range pow {
		pow[i] = 1&lt;&lt;uint(i)
	}
	for _, value := range pow {
		fmt.Printf("%d\n", value)
	}
}
</div>
</div>

<div class="slide">
	<h2>Switch</h2>
	<p>
	Probablemente ya sabes cómo iba a ser la cláusula <code>switch</code>.
	<p>
	El cuerpo de un caso sale automáticamente de la cláusula
	<code>switch</code>, a menos que termine con una sentencia
	<code>fallthrough</code>, que provocaría que siguiera ejecutando el
	siguiente caso contemplado.

<div>
package main

import (
	"fmt"
	"runtime"
)

func main() {
	fmt.Print("Go runs on ")
	switch os := runtime.GOOS; os {
	case "darwin":
		fmt.Println("OS X.")
	case "linux":
		fmt.Println("Linux.")
	default:
		// freebsd, openbsd,
		// plan9, windows...
		fmt.Printf("%s.", os)
	}
}
</div>
</div>

<div class="slide">
	<h2>Switch</h2>
	<p>
	Los casos de un Switch evaluan los casos de arriba a abajo, parando cuando
	se encuentra un caso satisfactorio.
	<p>
	(Por ejemplo,
	<pre>
switch i {
case 0:
case f():
}</pre>
	<p>
	no ejecuta <code>f</code> si <code>i==0</code>.)

<div>
package main

import (
	"fmt"
	"time"
)

func main() {
	fmt.Println("¿Cuándo es Sábadoy?")
	today := time.LocalTime().Weekday
	switch time.Saturday {
	case today+0:
		fmt.Println("Hoy.")
	case today+1:
		fmt.Println("Mañana.")
	case today+2:
		fmt.Println("Dentro de dos días.")
	default:
		fmt.Println("Demasiado tarde.")
	}
}
</div>
</div>

<div class="slide">
	<h2>Switch</h2>
	<p>
	Un switch sin condición es lo mismo que <code>switch true</code>.

<div>
package main

import (
	"fmt"
	"time"
)

func main() {
	t := time.LocalTime()
	switch {
	case t.Hour < 12:
	    fmt.Println("¡Buenos días!")
	case t.Hour < 17:
	    fmt.Println("Buenas tardes.")
	default:
	    fmt.Println("Buenas noches.")
	}
}
</div>
</div>

<div class="slide">
	<h2>Ejercicio: Bucles y Funciones</h2>
	<p>
	Una forma sencilla de jugar con funciones y bucles es implementar la
	funcionalidad de la raíz cuadrada utilizando el método de Newton.
	<p>
	En este caso el método de Newton aproxima <code>Sqrt(x)</code> tomando un
	punto inicial <i>z</i> y repitiendo:
	<center>
	<img src="https://chart.googleapis.com/chart?cht=tx&chl=z=z-\frac{z^2-x}{2z}">
	</center>
	<p>
	Para empezar, simplemente repite el cálculo 10 veces y mira cómo de cerca
	estás de la solución para distintos valores (1, 2, 3, ...).
	<p>
	Después cambia la condición del bucle para parar cuando el valor deje de
	cambiar (o solo cambie con un delta muy pequeño).
	Mira si esto ocurre con más o menos iteraciones. ¿Cómo estás de cerca
	comparado con <a target="_blank" href="http://golang.org/pkg/math/#Sqrt">math.Sqrt</a>?
	<p>
	Pista: para declarar e inicializar un valor decimal dale un valor decimal
	o utiliza la conversión:
	<pre>
	z := float64(0)
	z := 0.0
	</pre>

<div>
package main

import (
	"fmt"
)

func Sqrt(x float64) float64 {
}

func main() {
	fmt.Println(Sqrt(2))
}
</div>
</div>

<div class="slide">
	<h2>Ejercicio: Maps</h2>
	<p>
	Implementa <code>ContadorPalabras</code>. Debería devolver un map con el
	número de veces que una  &ldquo;palabra&rdquo; aparece en la cadena <code>s</code>.
	La función <code>wc.Test</code> ejecuta un caso de prueba ejecutando la
	función implementada e imprime éxito o fallo.
	<p>
	Puedes encontrar ayuda en  <a target="_blank" href="http://golang.org/pkg/strings/#Fields">strings.Fields</a>.

<div>
package main

import (
	"<span class="appengineMode">tour</span><span class="localMode">go-tour.googlecode.com/hg</span>/wc"
)

func ContadorPalabras(s string) map[string]int {
	return map[string]int{"x": 1}
}

func main() {
	wc.Test(ContadorPalabras)
}
</div>
</div>

<div class="slide">
	<h2>Ejercicio: Slices</h2>
	<p>
	Implementa la función <code>Pic</code>. Debería devolver un slice de tamaño
	<code>dy</code>, siendo cada uno de los elementos un slice de
	<code>dx</code> enteros sin signo de 8 bits. Cuando ejecutes el programa,
	mostrará tu dibujo, interpretando los números enteros como una escala de
	grises (bueno, escala de azules).
	<p>
	La elección de la imagen es de tu elección.
	Algunas funciones interesantes pueden ser <code>x^y</code>,
	<code>(x+y)/2</code>, y <code>x*y</code>.
	<p>
	(Necesitas usar un bucle para reservar memoria para cada
	<code>[]uint8</code> dentro de la matriz <code>[][]uint8</code>.)

<div>
package main

import "<span class="appengineMode">tour</span><span class="localMode">go-tour.googlecode.com/hg</span>/pic"

func Pic(dx, dy int) [][]uint8 {
}

func main() {
	pic.Show(Pic)
}
</div>
</div>

<div class="slide">
	<h2>Ejercicio: La clausura de Fibonacci</h2>
	<p>
	Vamos a divertirnos un poco con las funciones.
	<p>
	Implementa una función de <code>fibonacci</code> que devuelva una función (o
	clausura) que devuelva los sucesivos números de fibonacci.

<div>
package main

import "fmt"

// fibonacci es una función que devuelve
// una función que devuelve un int.
func fibonacci() func() int {
}

func main() {
	f := fibonacci()
	for i := 0; i < 10; i++ {
		fmt.Println(f())
	}
}
</div>
</div>

<div class="slide">
	<h2>Ejercicio avanzado: Raices cúbicas complejas</h2>
	<p>
	Veamos cuál es el soporte de Go para números complejos mediante los tipos 
	<code>complex64</code> y <code>complex128</code>.
	Para raíces cuadradas el método de Newton se basa en repeticiones:
	<center>
	<img src="https://chart.googleapis.com/chart?cht=tx&chl=z=z-\frac{z^3-x}{3z^2}">
	</center>
	<p>
	Busca la raíz cúbica de 2, para asegurarte que el algoritmo funciona. Existe
	una función <a target="_blank" href="http://golang.org/pkg/cmath/#Pow">cmath.Pow</a>.

<div>
package main

import "fmt"

func Cbrt(x complex128) complex128 {
}

func main() {
	fmt.Println(Cbrt(2))
}
</div>
</div>


<div class="toc">Métodos e Interfaces</div>

<div class="slide nocode">
	<h2>Métodos e Interfaces</h2>
</div>

<div class="slide">
	<h2>Métodos</h2>
	<p>
	Go no tiene clases. De todas formas, puedes definir métodos para tipos
	struct.
	<p>
	El <i>receptor del método</i> aparece en su propia lista de argumentos entre
	la palabra reservada <code>func</code> y el nombre del método.
<div>
package main

import (
	"fmt"
	"math"
)

type Vertex struct {
	X, Y float64
}

func (v *Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func main() {
	v := &Vertex{3, 4}
	fmt.Println(v.Abs())
}
</div>
</div>

<div class="slide">
	<h2>Métodos</h2>
	<p>
	De hecho, puedes definir un método para <i>cualquier</i> tipo que definas en
	tu paquete, no sólamente para estructuras.
	<p>
	No puedes definir un método de un tipo de otro paquete o de un tipo básico.
<div>
package main

import (
	"fmt"
	"math"
)

type MyFloat float64

func (f MyFloat) Abs() float64 {
	if f < 0 {
		return float64(-f)
	}
	return float64(f)
}

func main() {
	f := MyFloat(-math.Sqrt2)
	fmt.Println(f.Abs())
}
</div>
</div>

<div class="slide">
	<h2>Métodos con punteros a receptores</h2>
	<p>
	Los métodos pueden asociarse con un tipo o un puntero a un tipo declarado.
	<p>
	Acabamos de ver dos métodos <code>Abs</code>. Uno para el puntero a un
	vértice	<code>*Vertex</code> y otro para el tipo <code>MyFloat</code>.
	<p>
	Hay dos razones para usar un receptor de tipo puntero.
	Primero, para evitar copiar el valor en cada llamada al método (más
	eficiente si el tipo usado es una estructura grande). Segundo, de tal forma
	que el método pueda modificar el valor a la que apunta el receptor.
	</ol>
	<p>
	Intenta cambiar las declaraciones de los métodos <code>Abs</code> y
	<code>Scale</code> para usar <code>Vertex</code> como el receptor, en lugar
	de <code>*Vertex</code>.
	<p>
	El método <code>Scale</code> no tiene efecto cuando <code>v</code> es un
	vértice	<code>Vertex</code>. <code>Scale</code> cambia <code>v</code>.
	Cuando<code>v</code> es un tipo (no un puntero) el método ve una copia del
	vértice <code>Vertex</code> y no puede mutar el valor original.
	<p>
	<code>Abs</code> funciona de cualquier forma. Sólo lee <code>v</code>.
	No importa si está leyendo el valor original (a través del puntero) o una
	copia del valor.
<div>
package main

import (
	"fmt"
	"math"
)

type Vertex struct {
	X, Y float64
}

func (v *Vertex) Scale(f float64) {
	v.X = v.X * f
	v.Y = v.Y * f
}

func (v *Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func main() {
	v := &Vertex{3, 4}
	v.Scale(5)
	fmt.Println(v, v.Abs())
}
</div>
</div>

<div class="slide">
	<h2>Interfaces</h2>
	<p>
	Una interfaz es un tipo de datos definido como un conjunto de métodos.
	<p>
	Un tipo interface puede contener cualquier tipo que implemente esos métodos.

<div>
package main

import (
	"fmt"
	"math"
)

type Abser interface {
	Abs() float64
}

func main() {
	var a Abser
	f := MyFloat(-math.Sqrt2)
	v := Vertex{3, 4}

	a = f  // a MyFloat implementa Abser
	a = &v // a *Vertex implementa Abser
	a = v  // a Vertex, NO implementa Abser

	fmt.Println(a.Abs())
}

type MyFloat float64

func (f MyFloat) Abs() float64 {
	if f < 0 {
		return float64(-f)
	}
	return float64(f)
}

type Vertex struct {
	X, Y float64
}

func (v *Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}
</div>
</div>

<div class="slide">
	<h2>Interfaces</h2>
	<p>
	Un tipo implementa una interfaz simplemente implementando los métodos.
	<p>
	<i>No hay declaración explícita.</i>
	<p>
	Las interfaces implícitas desacoplan la implementación de paquetes entre los
	paquetes que definen las interfaces: ninguno depende de otro.
	<p>
	También favorece la definición de interfaces precisas, porque no tienes que
	encontrar todas las implementaciones y etiquetarlas con el nuevo nombre de
	la interfaz.
	<p>
	<a target="_blank" href="http://golang.org/pkg/io/">El paquete io</a> define
	<code>Reader</code> y <code>Writer</code>; Tú no tienes que hacerlo.
<div>
package main

import (
	"fmt"
	"os"
)

type Reader interface {
	Read(b []byte) (n int, err os.Error)
}

type Writer interface {
	Write(b []byte) (n int, err os.Error)
}

type ReadWriter interface {
	Reader
	Writer
}

func main() {
	var w Writer

	// os.Stdout implementa Writer
	w = os.Stdout

	fmt.Fprintf(w, "hello, writer\n")
}
</div>
</div>

<div class="slide">
	<h2>Errores</h2>
	<p>
	Un error es cualquier cosa que se defina así mismo:
	<pre>
package os

type Error interface {
	String() string
}
	</pre>

<div>
package main

import (
	"fmt"
	"os"
	"time"
)

type MyError struct {
	When *time.Time
	What string
}

func (e *MyError) String() string {
	return fmt.Sprintf("at %v, %s",
		e.When, e.What)
}

func run() os.Error {
	return &MyError{
		time.LocalTime(),
		"it didn't work",
	}
}

func main() {
	if err := run(); err != nil {
		fmt.Println(err)
	}
}
</div>
</div>

<div class="slide">
	<h2>Servidores Web</h2>
	<p>
	<a target="_blank" href="http://golang.org/pkg/http/">El paquete http</a>
	sirve peticiones HTTP usando cualquier valor que implemente <code>http.Handler</code>:
	<pre>
package http

type Handler interface {
	ServeHTTP(w ResponseWriter,
	          r *Request)
}
	</pre>
	<p>
	En este ejemplo, el tipo <code>MyHandler</code> implementa <code>http.Handler</code>.
	<p>
	<span class="localMode">
	Visita <a href="http://localhost:4000/"
		target="_blank">http://localhost:4000/</a> para ver la bienvenida.
	</span>
	<span class="appengineMode">
	<b>Nota:</b> Este ejemplo sólo se puede ejecutar a través del tour web
	local. Para intentar implementar servidores web puedes 
	<a target="_blank" href="http://golang.org/doc/install.html">Instalar
	Go</a>.
	</span>
<div>
package main

import (
	"fmt"
	"http"
)

type Hello struct{}

func (h Hello) ServeHTTP(
		w http.ResponseWriter,
		r *http.Request) {
	fmt.Fprint(w, "¡Hola!")
}

func main() {
	var h Hello
	http.ListenAndServe("localhost:4000",h)
}
</div>
</div>

<div class="slide">
	<h2>Imágenes</h2>
	<p>
	<a target="_blank" href="http://golang.org/pkg/image/#Image">El paquete
		image</a> define la interfaz <code>Image</code>:
	<pre>
package image

type Image interface {
	ColorModel() ColorModel
	Bounds() Rectangle
	At(x, y int) Color
}</pre>
	<p>
	(Mira <a target="_blank" href="http://golang.org/pkg/image/#Image">la
	documentación</a> para más detalles.)
	<p>
	<code>Color</code> y <code>ColorModel</code> también son interfaces, pero
	las ignoraremos usando las implementaciones predefinidas
	<code>image.RGBAColor</code> y <code>image.RGBAColorModel</code>.

<div>
package main

import (
	"fmt"
	"image"
)

func main() {
	m := image.NewRGBA(100, 100)
	fmt.Println(m.Bounds())
	fmt.Println(m.At(0, 0).RGBA())
}
</div>
</div>

<div class="slide">
	<h2>Ejercicio: Errores</h2>
	<p>
	Copia tu función <code>Sqrt</code> de ejercicios anteriores y modifícala
	para que devuelva un valor de tipo <code>os.Error</code>.
	<p>
	<code>Sqrt</code> debe devolver un error no nulo cuando se le pasa un número
	negativo, dado que no soporta números complejos.
	<p>
	Crea un nuevo tipo
	<pre>
type ErrNegativeSqrt float64</pre>
	<p>
	y hazlo del tipo <code>os.Error</code> implementando un método 
	<pre>
func (e ErrNegativeSqrt) String() string</pre>
	<p>
	de forma que <code>ErrNegativeSqrt(-2).String()</code> devuelva
	<code>"no se puede calbular la raíz de un número negativo: -2"</code>.
	<p>
	<b>Nota:</b> una llamada a <code>fmt.Print(e)</code> dentro del método
	<code>String</code> hará que el programa entre en un bucle infinito.
	Puedes evitarlo convirtiendo <code>e</code>:
	<code>fmt.Print(float64(e))</code>. ¿Por qué?
	<p>
	Cambia tu función <code>Sqrt</code> para devolver un valor
	<code>ErrNegativeSqrt</code> cuando se le pase un número negativo.
<div>
package main

import (
	"fmt"
	"os"
)

func Sqrt(f float64) (float64, os.Error) {
	return 0, nil
}

func main() {
	fmt.Println(Sqrt(2))
	fmt.Println(Sqrt(-2))
}
</div>
</div>

<div class="slide localMode">
	<h2>Ejercicio: Manejadores HTTP</h2>
	<p>
	Implementa los siguientes tipos y define métodos ServeHTTP para ellos.
	Asígnalos distintas rutas de tu servidor web.
<pre>type String string
	
type Struct struct {
	Greeting string
	Punct    string
	Who      string
}</pre>
	<p>
	Por ejemplo, deberías poder asignárselas usando:
<pre>http.Handle("/string", String("I'm a frayed knot."))
http.Handle("/struct", &Struct{"Hola", ":", "Gophers!"})</pre>
<div>
package main

import (
	"http"
)

func main() {
	// Tu http.Handle llama aquí
	http.ListenAndServe("localhost:4000", nil)
}
</div>
</div>

<div class="slide">
	<h2>Ejercicio: Imágenes</h2>
	<p>
	¿Recuerdas el generador de imágenes que escribiste antes?
	Vamos a escribir otro, pero esta vez devolverá una implementación de
	<code>image.Image</code> en lugar de un slice.
	<p>
	Define tu propio tipo <code>Image</code>, implementa
	<a target="_blank" href="http://golang.org/pkg/image/#Image"
		target="_blank">los métodos necesarios</a>, y llama a <code>pic.ShowImage</code>.
	<p>
	<code>Bounds</code> deberían devolver un <code>image.Rectangle</code>,
	como
	<code>image.Rect(0, 0, w, h)</code>.
	<p>
	<code>ColorModel</code> debería devolver <code>image.RGBAColorModel</code>.
	<p>
	<code>At</code> debería devolver un color;
	el valor <code>v</code> del último generador corresponde a 
	<code>image.RGBAColor{v, v, 255, 255}</code>.

<div>
package main

import (
	"image"
	"<span class="appengineMode">tour</span><span class="localMode">go-tour.googlecode.com/hg</span>/pic"
)

type Image struct{}

func main() {
	m := Image{}
	pic.ShowImage(m)
}
</div>
</div>

<div class="slide">
	<h2>Ejercicio: Lector Rot13</h2>
	<p>
	Un patrón común es un 
	<a target="_blank" href="http://golang.org/pkg/io/#Reader">io.Reader</a> que
	encapsula otro <code>io.Reader</code>, modificando el flujo de datos de
	alguna forma.
	<p>
	Por ejemplo, la función 
	<a target="_blank" href="http://golang.org/pkg/compress/gzip/#Decompressor.NewReader">gzip.NewReader</a>
	recibe un <code>io.Reader</code> (un flujo de datos en formato gzip)
	y devuelve un <code>*gzip.Decompressor</code> que también implementa
	<code>io.Reader</code> (un flujo de datos descomprimidos).
	<p>
	Implementa un <code>rot13Reader</code> que implemente 
	<code>io.Reader</code> y lea de un <code>io.Reader</code>,
	modificando el flujo de datos aplicándole el algoritmo de cifrado
	<a target="_blank" href="http://es.wikipedia.org/wiki/ROT13">ROT13</a>
	a todos los caracteres alfabéticos.
	<p>
	El tipo <code>rot13Reader</code> está completo. Implementa su método
	<code>Read</code> para que implemente la interfaz <code>io.Reader</code>.
<div>
package main

import (
	"io"
	"os"
	"strings"
)

type rot13Reader struct {
	r io.Reader
}

func main() {
	s := strings.NewReader(
		"Lbh penpxrq gur pbqr!")
	r := rot13Reader{s}
	io.Copy(os.Stdout, &r)
}
</div>
</div>

<div class="toc">Concurrencia</div>

<div class="slide nocode">
<h2>Concurrencia</h2>
</div>

<div class="slide">
	<h2>Gorutinas</h2>
	<p>
	Una <i>gorutina</i> es un hilo ligero manejado por el runtime de Go.
	<pre>go f(x, y, z)</pre>
	<p>
	comienza una nueva gorutina ejecutando
	<pre>f(x, y, z)</pre>
	<p>
	La evaluación de
        <code>f</code>, <code>x</code>, <code>y</code>, y <code>z</code>
        ocurre en la gorutina actual y la ejecución de <code>f</code>
	sucede en una nueva gorutina.
	<p>
	Las gorutinas ejecutan dentro del mismo espacio de direcciones, así que el
	acceso a memoria compartida debe ser síncronizado. El paquete <code><a href="http://golang.org/pkg/sync/"
	target="_blank">sync</a></code> provee de llamadas útiles, aunque no las
	necesitarás demasiado ya que Go provee otro tipo de primitivas. (Mira la
	siguiente transparencia.)
<div>
package main

import (
	"fmt"
	"<span class="appengineMode">runtime</span><span class="localMode">time</span>"
)

func say(s string) {
	for i := 0; i < 5; i++ {
		<span class="appengineMode">runtime.Gosched()</span><span class="localMode">time.Sleep(100e6)</span>
		fmt.Println(s)
	}
}

func main() {
	go say("mundo")
	say("hola")
}
</div>
</div>

<div class="slide">
	<h2>Canales</h2>

	<p>
	Los canales son un tipo de datos a través de los cuales puedes enviar
	o recibir valores con el operador <code>&lt;-</code>.
<pre>
ch <- v    // Envía v al canal ch.
v := <-ch  // Recibe del canal ch y
           // asigna el valor a v.
</pre>
	<p>
	(Los datos fluyen en la dirección de la "flecha".)

	<p>
	De la misma forma que los maps y slices, los canales deben crearse antes de
	usarlos:
<pre>
ch := make(chan int)
</pre>

	<p>
	Por defecto, los envíos y recepciones se bloquean hasta que el otro extremo
	está listo. Esto permite que las gorutinas se sincronicen sin cerrojos
	explícitos o variables condicionales.
<div>
package main

import "fmt"

func sum(a []int, c chan int) {
	sum := 0
	for _, v := range a {
		sum += v
	}
	c <- sum  // envía sum a c
}

func main() {
	a := []int{7, 2, 8, -9, 4, 0}

        c := make(chan int)
	go sum(a[:len(a)/2], c)
	go sum(a[len(a)/2:], c)
        x, y := <-c, <-c  // recibe de c

	fmt.Println(x, y, x + y)
}
</div>
</div>


<div class="slide">
	<h2>Canales con buffer</h2>
	
	<p>
	Los canales pueden tener un <i>buffer</i>. Se puede indicar el tamaño del
	buffer pasando un segundo argumento a <code>make</code> para inicializar un
	canal con buffer de recepción:
<pre>
ch := make(chan int, 100)
</pre>

	<p>
	Los envíos a un canal con buffer se bloquean sólo si el buffer está lleno.
	Las recepciones se bloquean si el buffer está vacío.

	<p>
	Modifica el ejemplo para llenar el buffer y observa qué ocurre.

<div>
package main

import "fmt"

func main() {
	c := make(chan int, 2)
	c <- 1
	c <- 2
	fmt.Println(<-c)
	fmt.Println(<-c)
}
</div>
</div>

<div class="slide">
	<h2>Range y Close</h2>
	<p>
	Un hilo que envía datos puede cerrar un canal para indicar que ya no se van
	a enviar más datos. Los receptores pueden comprobar si un canal ha sido
	cerrado asignando un segundo parámetro en la expresión de recepción:
	<pre>
v, ok := &lt;-ch</pre>
	<p>
	<code>ok</code> es <code>false</code> si no hay más valores que recibir y el
	canal está cerrado.
	<p>
	El bucle <code>for i := range c</code> recibe valores de un canal de forma
	repetida hasta que éste es cerrado.
	<p>
	<b>Nota:</b> Sólo el hilo que envía datos debería cerrar un canal, nunca el
	receptor. Los envíos a un canal cerrado generarán una excepción.
	<p>
	<b>Otra nota:</b> Los canales no son como ficheros; normalmente no necesitas
	cerrarlos. Cerrar un canal sólo es necesario cuando el receptor debe ser
	avisado que no va a recibir más datos.
<div>
package main

import (
	"fmt"
)

func fibonacci(n int, c chan int) {
        x, y := 1, 1
        for i := 0; i < n; i++ {
                c <- x
                x, y = y, x + y
        }
        close(c)
}

func main() {
        c := make(chan int, 10)
	go fibonacci(cap(c), c)
        for i := range c {
                fmt.Println(i)
        }
}
</div>
</div>

<div class="slide">
	<h2>Select</h2>
	<p>
	La cláusula <code>select</code> permite a una gorutina esperar diversas
	operaciones de comunicación.
	<p>
	Un <code>select</code> se bloquea hasta que uno de sus casos puede ser
	ejecutado, ejecutando el caso que ha satisfecho su condición. Elige uno al
	azar si hay varios listos.
<div>
package main

import "fmt"

func fibonacci(c, quit chan int) {
        x, y := 1, 1
        for {
                select {
                case c <- x:
                          x, y = y, x + y
                case <-quit:
			fmt.Println("sale")
                        return
                }
        }
}

func main() {
        c := make(chan int)
	quit := make(chan int)
	go func() {
		for i := 0; i < 10; i++ {
			fmt.Println(<-c)
		}
		quit <- 0
	}()
	fibonacci(c, quit)
}
</div>
</div>

<div class="slide">
	<h2>Select por defecto</h2>
	<p>
	El caso <code>default</code> en una cláusula <code>select</code> ejecuta si
	no hay otro caso listo.
	<p>
	Utiliza un caso <code>default</code> para intentar enviar o recibir de forma
	no bloqueante:
	<pre>
select {
case i := <-c:
	// use i
default:
	// receiving from c would block
}</pre>
	<p>
	<span class="appengineMode">
		<b>Nota:</b> Este ejemplo no ejecutará en la versión web porque el 
	<a target="_blank" href="http://golang.org/doc/play/">entorno posee una sandbox
	</a> que no tiene el concepto de tiempo. Quizá quieras 
	<a target="_blank" href="http://golang.org/doc/install.html">instalar
		Go</a> para ver este ejemplo en acción.
	</span>
<div>
package main

import (
	"fmt"
	"time"
)

func main() {
        tick := time.Tick(1e8)
        boom := time.After(5e8)
        for {
                select {
                case <-tick:
                        fmt.Println("tick.")
                case <-boom:
                        fmt.Println("BOOM!")
                        return
                default:
                        fmt.Println("    .")
                        time.Sleep(5e7)
                }
        }
}
</div>
</div>

<div class="slide nocode">
	<h2>Ejercicio: Árboles binarios equivalentes</h2>
	<p>
	Hay muchos árboles binarios con la misma secuencia de valores almacenadas en
	las hojas.
	Por ejemplo, aquí hay dos árboles binarios almacenando la secuencia
	1, 1, 2, 3, 5, 8, 13.
	<img src="static/fig4.png">
	<p>
	Una función para comprobar que dos árboles binarios almacenan la misma
	secuencia es bastante compleja en la mayoría de los lenguajes de
	programación. Usaremos la concurrencia de Go y los canales para escribir una
	solución sencilla.
	<p>
	Este ejemplo usa el paquete <code>tree</code>, que define el tipo:
<pre>
type Tree struct {
	Left  *Tree
	Value int
	Right *Tree
}
</pre>
</div>

<div class="slide">
	<h2>Ejercicio: Árboles binarios equivalentes</h2>
	<p>
	<b>1.</b> Implementa la función <code>Walk</code>.
	<p>
	<b>2.</b> Testea la función <code>Walk</code>.
	<p>
	La función <code>tree.New(k)</code> construye un árbol binario de estructura
	aleatoria con los valores <code>k</code>, <code>2k</code>, <code>3k</code>, ...,
	<code>10k</code>.
	<p>
	Crea un nuevo canal <code>ch</code> y lanza la función Walk:
<pre>
go Walk(tree.New(1), ch)
</pre>
	<p>
	Después lee e imprime 10 valores del canal.
	Deberían ser los números 1, 2, 3, ..., 10.
	<p>
	<b>3.</b> Implementa la función <code>Same</code> usando la función <code>Walk</code>
	para determinar si <code>t1</code> y <code>t2</code> almacenan los mismos
	valores.
	<p>
	<b>4.</b> Testea la función <code>Same</code>.
	<p>
	<code>Same(tree.New(1), tree.New(1))</code> debería devolver true, y
	<code>Same(tree.New(1), tree.New(2))</code> debería devolver false.

<div>
package main

import "<span class="appengineMode">tour</span><span class="localMode">go-tour.googlecode.com/hg</span>/tree"

// Walk lee el árbol t enviando todos los valores
// del árbol al canal ch.
func Walk(t *tree.Tree, ch chan int)

// Same determina si los árboles
// t1 and t2 contienen los mismos valores.
func Same(t1, t2 *tree.Tree) bool

func main() {
}
</div>
</div>

<div class="slide">
	<h2>Ejercicio: Web Crawler</h2>
	<p>
	En este ejercicio usarás las características de concurrencia de Go para
	paralelizar un web crawler.
	<p>
	Modifica la función <code>Crawl</code> para obtener las URLs en paralelo sin
	obtener la misma URL dos veces.
<div>
package main

import (
	"os"
	"fmt"
)

type Fetcher interface {
	// Fetch devuelve el cuerpo de una URL
	// un slice con las URLs encontradas en esa página.
	Fetch(url string) (body string, urls []string, err os.Error)
}

// Crawl usa fetcher para recorrer recursivamente
// las páginas empezando por url, hasta un máximo de depth.
func Crawl(url string, depth int, fetcher Fetcher) {
	// TODO: Obtener URLs en paralelo.
	// TODO: No obtengas la misma URL dos veces.
	// Esta implementación tampoco lo hace:
	if depth <= 0 {
		return
	}
	body, urls, err := fetcher.Fetch(url)
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Printf("found: %s %q\n", url, body)
	for _, u := range urls {
		Crawl(u, depth-1, fetcher)
	}
	return
}

func main() {
	Crawl("http://golang.org/", 4, fetcher)
}


// fakeFetcher es un Fetcher que devuelve resultados repetidos.
type fakeFetcher map[string]*fakeResult

type fakeResult struct {
	body string
	urls     []string
}

func (f *fakeFetcher) Fetch(url string) (string, []string, os.Error) {
	if res, ok := (*f)[url]; ok {
		return res.body, res.urls, nil
	}
	return "", nil, fmt.Errorf("not found: %s", url)
}

var fetcher = &fakeFetcher{
	"http://golang.org/": &fakeResult{
		"The Go Programming Language",
		[]string{
			"http://golang.org/pkg/",
			"http://golang.org/cmd/",
		},
	},
	"http://golang.org/pkg/": &fakeResult{
		"Packages",
		[]string{
			"http://golang.org/",
			"http://golang.org/cmd/",
			"http://golang.org/pkg/fmt/",
			"http://golang.org/pkg/os/",
		},
	},
	"http://golang.org/pkg/fmt/": &fakeResult{
		"Package fmt",
		[]string{
			"http://golang.org/",
			"http://golang.org/pkg/",
		},
	},
	"http://golang.org/pkg/os/": &fakeResult{
		"Package os",
		[]string{
			"http://golang.org/",
			"http://golang.org/pkg/",
		},
	},
}
</div>
</div>

<div class="slide nocode">
	<h2>Por dónde continuar...</h2>
	<p class="appengineMode">
	Puedes comenzar 
	<a href="http://golang.org/doc/install.html">instalando Go</a> o
	descargándote el SDK de
	<a href="http://code.google.com/appengine/downloads.html#Google_App_Engine_SDK_for_Go">Go App Engin</a>.
	</p>
	<p>
	<span class="appengineMode">Una vez que lo tengas ejecutando en tu
		ordenador, la</span>
	<span class="localMode">la</span>
	<a target="_blank" href="http://golang.org/doc/docs.html">Documentación de Go</a>
	es un buen lugar para 
	<span class="appengineMode">continuar</span>
	<span class="localMode">empezar</span>.
	Contiene referencias a tutoriales, videos, y mucho más.
	<p>
	Si necesitas ayuda con la biblioteca estándar echa un vistazo a <a
		target="_blank" href="http://golang.org/pkg/">la API de los
		paquetes</a>. Para ayuda con el lenguaje, puedes asombrarte con la
	facilidad de lectura de la
	<a target="_blank" href="http://golang.org/doc/go_spec.html">especificación
	del lenguaje</a>.
<p>
	Si estás interesado en escribir aplicaciones web, échale un vistazo a la 
	<a target="_blank" href="http://golang.org/doc/codelab/wiki/">Wiki
	Codelab</a>.
	<p>
	Si quieres explorar más a fondo el modelo de concurrencia de Go, échale un
	vistazo al documento
	<a target="_blank" href="http://golang.org/doc/codewalk/sharemem/">Comparte
	memoria comunicándote</a>.
	<p>
	El documento <a target="_blank"
		href="http://golang.org/doc/codewalk/functions/">Funciones de primera
		clase de Go</a> otorga una interesante perspectiva de los tipos de
	funciones en Go.
	<p>
	El <a target="_blank" href="http://blog.golang.org/">Blog de Go</a> tiene un
	gran archivo de artículos informativos de Go.
	<p>
	Visita <a target="_blank" href="http://golang.org">golang.org</a>.
</div>

</div><!-- end slides -->

</body>
</html>
